# Running Embedded Rust on the Pi Pico

## Overview
This was a project I worked on for an internship at Harsch Systems in the summer of 2021.

The goal of the project was to write code for the RP2040 microcontroller on the Raspberry Pi Pico system, in Rust. The SDK provided by the Raspberry Pi Foundation is written in C (at https://github.com/raspberrypi/pico-sdk), and so was not an option to use, but was a good reference as I worked on debugging this project.

## Embedded Rust
I will give a quick overview here of some important parts, but the information and images are pulled from a much more comprehensive tutorial at https://docs.rust-embedded.org/book/intro/index.html.

The structure of embedded Rust is a little bit different than people familiar with embedded C may be used to. Unlike embedded C, where we have one SDK, in embedded Rust there are a few crates we use as abstraction layers between our embedded code and the bare metal machine code.

![Embedded Rust Crates](images/crates.png?raw=true "Embedded Rust Crates")

#### Micro-Architecture Crate
First of all, we have micro architecture crates, which provides some useful routines common to the given architecture, like panic behavior and semihosting. In this case, we are using the cortex-m crate found at https://github.com/rust-embedded/cortex-m. 

#### Peripheral Access Crate (PAC)
Next, we have the PAC, which gives a very basic connection between peripherals and their addresses. These crates are usually as limited as, for example, just exposing functions to write to I2C related registers without having to look up their addresses each time. They're usually generated by a computer from a SVD file (a file which contains a complete description of the system and the locations and names of registers), and only edited when the computer makes suboptimal decisions or mistakes. In this case, we are using the PAC found at https://github.com/rp-rs/rp2040-pac.

#### Hardware Abstraction Layer (HAL)
In a HAL, the register access in the PAC and the capabilities of the micro-architecture crate are combined to abstract away system specific details from the user. HALs are most like the C SDK provided for the pi pico. For example, if you tried to control a board with only the PAC, turning on an LED would involve resetting the IO and Pads banks, setting a pin to be an output, setting the pull direction on the pin, connectting the pin to a GPIO, enabling it, and then writing a 1 to turn it on. The HAL deals with all of these details for you. Unfortunately, when I started this project, the rp2040 HAL was still in development (https://github.com/rp-rs/rp-hal), so while I could use it to control a GPIO, I could not control PWM or ADC outputs, which I needed.

## Getting Started
Since I didn't have a finished HAL to work with, I had to become intimately familiar with the operation of the RP2040 microcontroller. The information on the datasheet (https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf) was invaluable, but it still wasn't easy. 

Before anything else, I jumped right into trying to implement the PWM using only what was on the datasheet. This was a bad idea, as I didn't have any experience with embedded rust, and I had no way of knowing what the code was doing once it was uploaded to the board. So, after banging my head into a wall for a bit, I switched tracks.

Next, I tried to implement a GPIO blink function. This was treading old ground, as the incomplete RP2040 HAL already had this functionality. However, it helped me to get a feel for embedded rust and, once finished, provided a rudimentary way to get feedback from the board. Most of the code in that file was extracted (read: copied) from the initialization and body code at the existing RP2040 HAL, with the main challenge being cutting it down to only the needed code for a blink function. Once this was done, I made my first commit to this repo.

## Interlude: Toolchain Setup
Before I get to far into this, I should describe my toolchain for running this code on the board. I used a fairly rudimentary system that was setup as follows:

// Basic compiler tools  
sudo apt install gcc-arm-non-eabi

// Some useful tools for interfacing with the RP2040 (I just use the elf2uf2 script, so this is really inefficient, I guess)  
git clone https://github.com/raspberrypi/pico-sdk --depth 1 --recursive --single-branch  
cd pico-sdk && mkdir build && cd build  
cmake .. && make //Requires cmake to be installed  
cd ../..

// The hardware abstraction layer
git clone https://github.com/rp-rs/rp-hal  
cd rp-hal/rp2040-hal  
rustup target add thumbv6m-none-eabi  
cd ..

Instead of downloaded the PAC, since I was using both, I just downloaded the HAL, and the PAC was included as a result. Once these were included, I could move one of these examples into the example folder of rp-hal and build them using:

cargo build --example "example name" --release

This was a benefit of just downloading the HAL, since it made building code fast and easy. Once this was built, the process to upload it to the board was also pretty simple. First, I converted the file to a .uf2 file using:

/path/to/piko-sdk/build/elf2uf2/elf2uf2 target/thumbv6m-none-eabi/release/examples/"example name" "example name".uf2

Then, to upload the code, I just plugged in the pi pico while holding down the BOOTSEL button. This made the pi pico reveal itself as a "usb stick" type device, which I could drag and drop the .uf2 file into. (Yeah, this was a pretty stupid toolchain. Don't judge me.)

## Implementing PWM
