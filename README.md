# Running Embedded Rust on the Pi Pico

## Overview
This was a project I worked on for an internship at Harsch Systems in the summer of 2021.

The goal of the project was to write code for the RP2040 microcontroller on the Raspberry Pi Pico system, in Rust. The SDK provided by the Raspberry Pi Foundation is written in C (at https://github.com/raspberrypi/pico-sdk), and so was not an option to use, but was a good reference as I worked on debugging this project.

## Embedded Rust
I will give a quick overview here of some important parts, but the information and images are pulled from a much more comprehensive tutorial at https://docs.rust-embedded.org/book/intro/index.html.

The structure of embedded Rust is a little bit different than people familiar with embedded C may be used to. Unlike embedded C, where we have one SDK, in embedded Rust there are a few crates we use as abstraction layers between our embedded code and the bare metal machine code.

![Embedded Rust Crates](images/crates.png?raw=true "Embedded Rust Crates")

#### Micro-Architecture Crate
First of all, we have micro architecture crates, which provides some useful routines common to the given architecture, like panic behavior and semihosting. In this case, we are using the cortex-m crate found at https://github.com/rust-embedded/cortex-m. 

#### Peripheral Access Crate (PAC)
Next, we have the PAC, which gives a very basic connection between peripherals and their addresses. These crates are usually as limited as, for example, just exposing functions to write to I2C related registers without having to look up their addresses each time. They're usually generated by a computer from a SVD file (a file which contains a complete description of the system and the locations and names of registers), and only edited when the computer makes suboptimal decisions or mistakes. In this case, we are using the PAC found at https://github.com/rp-rs/rp2040-pac.

#### Hardware Abstraction Layer (HAL)
In a HAL, the register access in the PAC and the capabilities of the micro-architecture crate are combined to abstract away system specific details from the user. HALs are most like the C SDK provided for the pi pico. For example, if you tried to control a board with only the PAC, turning on an LED would involve resetting the IO and Pads banks, setting a pin to be an output, setting the pull direction on the pin, connectting the pin to a GPIO, enabling it, and then writing a 1 to turn it on. The HAL deals with all of these details for you. Unfortunately, when I started this project, the rp2040 HAL was still in development (https://github.com/rp-rs/rp-hal), so while I could use it to control a GPIO, I could not control PWM or ADC outputs, which I needed.

## Getting Started
Since I didn't have a finished HAL to work with, I had to become intimately familiar with the operation of the RP2040 microcontroller. The information on the datasheet (https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf) was invaluable, but it still wasn't easy. 

Before anything else, I jumped right into trying to implement the PWM using only what was on the datasheet. This was a bad idea, as I didn't have any experience with embedded rust, and I had no way of knowing what the code was doing once it was uploaded to the board. So, after banging my head into a wall for a bit, I switched tracks.

Next, I tried to implement a GPIO blink function. This was treading old ground, as the incomplete RP2040 HAL already had this functionality. However, it helped me to get a feel for embedded rust and, once finished, provided a rudimentary way to get feedback from the board. Most of the code in that file was extracted (read: copied) from the initialization and body code at the existing RP2040 HAL, with the main challenge being cutting it down to only the needed code for a blink function. Once this was done, I made my first commit to this repo.

## Interlude: Toolchain Setup
Before I get to far into this, I should describe my toolchain for running this code on the board. I used a fairly rudimentary system that was setup as follows:

// Basic compiler tools  
sudo apt install gcc-arm-non-eabi

// Some useful tools for interfacing with the RP2040 (I just use the elf2uf2 script, so this is really inefficient, I guess)  
git clone https://github.com/raspberrypi/pico-sdk --depth 1 --recursive --single-branch  
cd pico-sdk && mkdir build && cd build  
cmake .. && make //Requires cmake to be installed  
cd ../..

// The hardware abstraction layer
git clone https://github.com/rp-rs/rp-hal  
cd rp-hal/rp2040-hal  
rustup target add thumbv6m-none-eabi  
cd ..

Instead of downloaded the PAC, since I was using both, I just downloaded the HAL, and the PAC was included as a result. Once these were included, I could move one of these examples into the example folder of rp-hal and build them using:

cargo build --example "example name" --release

This was a benefit of just downloading the HAL, since it made building code fast and easy. Once this was built, the process to upload it to the board was also pretty simple. First, I converted the file to a .uf2 file using:

/path/to/piko-sdk/build/elf2uf2/elf2uf2 target/thumbv6m-none-eabi/release/examples/"example name" "example name".uf2

Then, to upload the code, I just plugged in the pi pico while holding down the BOOTSEL button. This made the pi pico reveal itself as a "usb stick" type device, which I could drag and drop the .uf2 file into. (Yeah, this was a pretty stupid toolchain. Don't judge me.)

## Implementing PWM
Implementing the PWM took a bit, but most of it was composed of finding dumb bugs. Right of the bat, it proceeded considerably faster with the capability to use my blink code to quickly test if the code was making it somewhere. I found a couple places where it was hanging on a reset, and a few other small details, but eventually it worked. Implementing the PWM was definitely the climax of my work on this repository, because after I finished it I moved on to trying to implement it into the RP2040 HAL. So, I will describe in some detail the necessary process for controlling a PWM on the pi pico:

In lines 21-27, I repeat the following process twice, to reset the io_bank and pwm:
1) Write to a reset register to reset a peripheral
2) Read from a register that is pulled low during the reset process, so we can wait for the reset to finish.  

Then, I proceed into some PWM specific functionality:
1) In line 29, I write 0 to bit 1 of CH0_CSR (datasheet 552) to disable phase correct mode (datasheet 545)  
2) In line 31, I write 0x01 to CH0_DIV (datasheet 552) to set the clock division value to 1 (datasheet 547)  
3) In line 33, I write write 0 to bits 4 and 5 of CH0_CSR (datasheet 552) to set the PWM output to be driven by the clock (datasheet 448)  
4) In line 35, I write 0 to bit 2 of CH0_CSR (datasheet 552) to keep it from inverting PWM channel A  
5) In line 37, I write 0 to bit 3 of CH0_CSR (datasheet 552) to keep it from inverting PWM channel B  
6) In line 39, I write 0xffff to CH0_TOP (datasheet 553) so that we have the highest granularity of output frequencies (datasheet 544)
7) In line 41, I write 0x7fff to the first 16 bits of CH0_CC (datasheet 553) so the duty cycle is 50% (0x7fff/CH0_TOP = .5) (datasheet 544)
8) In line 43, I write 0x0000 to CH0_CTR (datasheet 553) to reset it (datasheet 544)
9) In line 45, I write 1 to bit 0 of CH0_CSR (datasheet 552) to enable it
10) In line 49, I write 1 to bit 6 of PADS_BANK0: GPIO0 (datasheet 321) to enable inputs on the pad
11) In line 50, I write 0 to bit 7 of PADS_BANK0: GPIO0 (datasheet 321) to enable outputs on the pad
12) In line 52, I write 0x4 (datasheet 258) to the first four bits of IO_BANK0: GPIO0_CTRL (datasheet 268) to connect the output to the PWM output

Note: Steps 10 and 11 look bad, but I got those from the C equivalents in the official pico-sdk, so they MUST be ok... right?

At this point, the PWM output should work. I also included a loop to toggle between the PWM counter being on and off, but that was more for fun :).

Once I'd finished this, I moved onto trying to make a HAL implementation. The result, found here, https://github.com/tystowell/rp-hal, was ok.
